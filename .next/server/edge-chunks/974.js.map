{"version":3,"file":"edge-chunks/974.js","mappings":"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","sources":["webpack://_N_E/./app/components/TransferModal.tsx","webpack://_N_E/./app/utils/eprfHistoryService.ts","webpack://_N_E/./app/utils/eprfService.ts","webpack://_N_E/./app/utils/userService.ts","webpack://_N_E/./app/utils/validation.ts"],"sourcesContent":["'use client'\r\n\r\nimport { useState, useEffect } from 'react'\r\nimport { User, getOtherLoggedInUsers, getCurrentUser } from '../utils/userService'\r\nimport * as api from '../utils/apiClient'\r\n\r\ninterface TransferModalProps {\r\n  isOpen: boolean\r\n  onClose: () => void\r\n  onTransferComplete: (targetUser: User) => void\r\n  incidentId: string\r\n  patientLetter?: string // If provided, transfer single patient. Otherwise transfer all.\r\n  isLoading?: boolean\r\n}\r\n\r\nexport default function TransferModal({\r\n  isOpen,\r\n  onClose,\r\n  onTransferComplete,\r\n  incidentId,\r\n  patientLetter,\r\n  isLoading = false\r\n}: TransferModalProps) {\r\n  const [users, setUsers] = useState<User[]>([])\r\n  const [selectedUser, setSelectedUser] = useState<User | null>(null)\r\n  const [showConfirmation, setShowConfirmation] = useState(false)\r\n  const [loadingUsers, setLoadingUsers] = useState(false)\r\n\r\n  useEffect(() => {\r\n    if (isOpen) {\r\n      loadUsers()\r\n      setSelectedUser(null)\r\n      setShowConfirmation(false)\r\n    }\r\n  }, [isOpen])\r\n\r\n  const loadUsers = async () => {\r\n    setLoadingUsers(true)\r\n    try {\r\n      // Try API first\r\n      const currentUser = getCurrentUser()\r\n      const apiUsers = await api.getActiveUsers()\r\n      \r\n      // Filter out current user and map to local User format\r\n      const otherUsers = apiUsers\r\n        .filter(u => u.discord_id !== currentUser?.discordId)\r\n        .map(u => ({\r\n          discordId: u.discord_id,\r\n          discordUsername: u.discord_username,\r\n          callsign: u.callsign,\r\n          vehicle: u.vehicle,\r\n          loginTime: u.last_login\r\n        }))\r\n      \r\n      if (otherUsers.length > 0) {\r\n        setUsers(otherUsers)\r\n      } else {\r\n        // Fallback to localStorage\r\n        setUsers(getOtherLoggedInUsers())\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to load users from API:', error)\r\n      // Fallback to localStorage\r\n      setUsers(getOtherLoggedInUsers())\r\n    } finally {\r\n      setLoadingUsers(false)\r\n    }\r\n  }\r\n\r\n  if (!isOpen) return null\r\n\r\n  const handleUserSelect = (user: User) => {\r\n    setSelectedUser(user)\r\n  }\r\n\r\n  const handleTransferClick = () => {\r\n    if (selectedUser) {\r\n      setShowConfirmation(true)\r\n    }\r\n  }\r\n\r\n  const handleConfirmTransfer = () => {\r\n    if (selectedUser) {\r\n      onTransferComplete(selectedUser)\r\n    }\r\n  }\r\n\r\n  const transferTarget = patientLetter \r\n    ? `Patient ${patientLetter} of ${incidentId}` \r\n    : `all patients of ${incidentId}`\r\n\r\n  return (\r\n    <div className=\"modal-overlay\" onClick={onClose}>\r\n      <style jsx>{`\r\n        .transfer-modal {\r\n          background: #fff;\r\n          border-radius: 12px;\r\n          max-width: 500px;\r\n          width: 90%;\r\n          box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);\r\n          overflow: hidden;\r\n        }\r\n\r\n        .transfer-header {\r\n          background: #0066cc;\r\n          color: white;\r\n          padding: 20px 25px;\r\n          font-size: 18px;\r\n          font-weight: 600;\r\n        }\r\n\r\n        .transfer-body {\r\n          padding: 25px;\r\n        }\r\n\r\n        .transfer-info {\r\n          background: #f0f4f8;\r\n          border-radius: 8px;\r\n          padding: 15px;\r\n          margin-bottom: 20px;\r\n          font-size: 14px;\r\n          color: #444;\r\n        }\r\n\r\n        .transfer-warning {\r\n          background: #fff3cd;\r\n          border: 1px solid #ffc107;\r\n          border-radius: 8px;\r\n          padding: 15px;\r\n          margin-bottom: 20px;\r\n          display: flex;\r\n          align-items: flex-start;\r\n          gap: 10px;\r\n        }\r\n\r\n        .warning-icon {\r\n          font-size: 20px;\r\n        }\r\n\r\n        .warning-text {\r\n          font-size: 13px;\r\n          color: #856404;\r\n        }\r\n\r\n        .users-list {\r\n          max-height: 250px;\r\n          overflow-y: auto;\r\n          border: 1px solid #e0e0e0;\r\n          border-radius: 8px;\r\n        }\r\n\r\n        .user-item {\r\n          display: flex;\r\n          align-items: center;\r\n          padding: 15px;\r\n          border-bottom: 1px solid #e0e0e0;\r\n          cursor: pointer;\r\n          transition: background 0.2s;\r\n        }\r\n\r\n        .user-item:last-child {\r\n          border-bottom: none;\r\n        }\r\n\r\n        .user-item:hover {\r\n          background: #f5f5f5;\r\n        }\r\n\r\n        .user-item.selected {\r\n          background: #e3f2fd;\r\n          border-left: 3px solid #0066cc;\r\n        }\r\n\r\n        .user-radio {\r\n          width: 20px;\r\n          height: 20px;\r\n          margin-right: 15px;\r\n        }\r\n\r\n        .user-info {\r\n          flex: 1;\r\n        }\r\n\r\n        .user-callsign {\r\n          font-weight: 600;\r\n          font-size: 15px;\r\n          color: #1a3a5c;\r\n        }\r\n\r\n        .user-vehicle {\r\n          font-size: 13px;\r\n          color: #666;\r\n          margin-top: 2px;\r\n        }\r\n\r\n        .user-login-time {\r\n          font-size: 12px;\r\n          color: #999;\r\n          margin-top: 2px;\r\n        }\r\n\r\n        .no-users {\r\n          padding: 40px 20px;\r\n          text-align: center;\r\n          color: #666;\r\n        }\r\n\r\n        .no-users-icon {\r\n          font-size: 40px;\r\n          margin-bottom: 10px;\r\n        }\r\n\r\n        .transfer-footer {\r\n          display: flex;\r\n          justify-content: flex-end;\r\n          gap: 12px;\r\n          padding: 20px 25px;\r\n          border-top: 1px solid #e0e0e0;\r\n          background: #f8f9fa;\r\n        }\r\n\r\n        .transfer-btn {\r\n          padding: 10px 24px;\r\n          font-size: 14px;\r\n          font-weight: 600;\r\n          border: none;\r\n          border-radius: 6px;\r\n          cursor: pointer;\r\n          transition: all 0.2s;\r\n        }\r\n\r\n        .transfer-btn:disabled {\r\n          opacity: 0.5;\r\n          cursor: not-allowed;\r\n        }\r\n\r\n        .transfer-btn-cancel {\r\n          background: #e0e0e0;\r\n          color: #333;\r\n        }\r\n\r\n        .transfer-btn-cancel:hover:not(:disabled) {\r\n          background: #d0d0d0;\r\n        }\r\n\r\n        .transfer-btn-confirm {\r\n          background: #dc3545;\r\n          color: white;\r\n        }\r\n\r\n        .transfer-btn-confirm:hover:not(:disabled) {\r\n          background: #c82333;\r\n        }\r\n\r\n        .confirmation-overlay {\r\n          position: absolute;\r\n          top: 0;\r\n          left: 0;\r\n          right: 0;\r\n          bottom: 0;\r\n          background: rgba(255, 255, 255, 0.95);\r\n          display: flex;\r\n          flex-direction: column;\r\n          align-items: center;\r\n          justify-content: center;\r\n          padding: 30px;\r\n          text-align: center;\r\n        }\r\n\r\n        .confirmation-icon {\r\n          font-size: 50px;\r\n          margin-bottom: 20px;\r\n        }\r\n\r\n        .confirmation-title {\r\n          font-size: 20px;\r\n          font-weight: 600;\r\n          color: #dc3545;\r\n          margin-bottom: 15px;\r\n        }\r\n\r\n        .confirmation-message {\r\n          font-size: 14px;\r\n          color: #555;\r\n          line-height: 1.6;\r\n          margin-bottom: 25px;\r\n          max-width: 350px;\r\n        }\r\n\r\n        .confirmation-buttons {\r\n          display: flex;\r\n          gap: 15px;\r\n        }\r\n      `}</style>\r\n      \r\n      <div className=\"transfer-modal\" onClick={e => e.stopPropagation()}>\r\n        <div className=\"transfer-header\">\r\n          Transfer ePRF\r\n        </div>\r\n        \r\n        <div className=\"transfer-body\" style={{ position: 'relative' }}>\r\n          <div className=\"transfer-info\">\r\n            <strong>Transferring:</strong> {transferTarget}\r\n          </div>\r\n          \r\n          <div className=\"transfer-warning\">\r\n            <span className=\"warning-icon\">‚ö†Ô∏è</span>\r\n            <span className=\"warning-text\">\r\n              This action is <strong>irreversible</strong>. The ePRF will be transferred to another user \r\n              and they will become the author. You will no longer be able to edit this record.\r\n            </span>\r\n          </div>\r\n          \r\n          {loadingUsers ? (\r\n            <div className=\"no-users\">\r\n              <div className=\"no-users-icon\">‚è≥</div>\r\n              <p>Loading users...</p>\r\n            </div>\r\n          ) : users.length > 0 ? (\r\n            <>\r\n              <p style={{ marginBottom: '12px', fontSize: '14px', color: '#555' }}>\r\n                Select a user to transfer to:\r\n              </p>\r\n              <div className=\"users-list\">\r\n                {users.map(user => (\r\n                  <div \r\n                    key={user.discordId}\r\n                    className={`user-item ${selectedUser?.discordId === user.discordId ? 'selected' : ''}`}\r\n                    onClick={() => handleUserSelect(user)}\r\n                  >\r\n                    <input \r\n                      type=\"radio\" \r\n                      className=\"user-radio\"\r\n                      checked={selectedUser?.discordId === user.discordId}\r\n                      onChange={() => handleUserSelect(user)}\r\n                    />\r\n                    <div className=\"user-info\">\r\n                      <div className=\"user-callsign\">{user.callsign}</div>\r\n                      <div className=\"user-vehicle\">{user.vehicle}</div>\r\n                      <div className=\"user-login-time\">\r\n                        Logged in: {new Date(user.loginTime).toLocaleTimeString('en-GB', { \r\n                          hour: '2-digit', \r\n                          minute: '2-digit' \r\n                        })}\r\n                      </div>\r\n                    </div>\r\n                  </div>\r\n                ))}\r\n              </div>\r\n            </>\r\n          ) : !loadingUsers && (\r\n            <div className=\"no-users\">\r\n              <div className=\"no-users-icon\">üë§</div>\r\n              <p>No other users are currently logged in.</p>\r\n              <p style={{ fontSize: '13px', marginTop: '5px' }}>\r\n                Ask another crew member to log in first.\r\n              </p>\r\n            </div>\r\n          )}\r\n          \r\n          {showConfirmation && selectedUser && (\r\n            <div className=\"confirmation-overlay\">\r\n              <div className=\"confirmation-icon\">üîÑ</div>\r\n              <div className=\"confirmation-title\">Confirm Transfer</div>\r\n              <div className=\"confirmation-message\">\r\n                You are about to transfer <strong>{transferTarget}</strong> to <strong>{selectedUser.callsign}</strong>.\r\n                <br /><br />\r\n                This cannot be undone. Are you sure?\r\n              </div>\r\n              <div className=\"confirmation-buttons\">\r\n                <button \r\n                  className=\"transfer-btn transfer-btn-cancel\"\r\n                  onClick={() => setShowConfirmation(false)}\r\n                  disabled={isLoading}\r\n                >\r\n                  Go Back\r\n                </button>\r\n                <button \r\n                  className=\"transfer-btn transfer-btn-confirm\"\r\n                  onClick={handleConfirmTransfer}\r\n                  disabled={isLoading}\r\n                >\r\n                  {isLoading ? 'Transferring...' : 'Yes, Transfer'}\r\n                </button>\r\n              </div>\r\n            </div>\r\n          )}\r\n        </div>\r\n        \r\n        {!showConfirmation && (\r\n          <div className=\"transfer-footer\">\r\n            <button \r\n              className=\"transfer-btn transfer-btn-cancel\"\r\n              onClick={onClose}\r\n              disabled={isLoading}\r\n            >\r\n              Cancel\r\n            </button>\r\n            <button \r\n              className=\"transfer-btn transfer-btn-confirm\"\r\n              onClick={handleTransferClick}\r\n              disabled={!selectedUser || isLoading}\r\n            >\r\n              Transfer ePRF\r\n            </button>\r\n          </div>\r\n        )}\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n","'use client'\r\n\r\n// ePRF History and Management Service\r\n// This service now uses the database API with localStorage as a cache\r\n\r\nimport * as api from './apiClient'\r\n\r\nexport interface EPRFRecord {\r\n  id: string\r\n  incidentId: string\r\n  patientLetter: string\r\n  status: 'incomplete' | 'complete'\r\n  author: string // discordId of the author\r\n  authorCallsign: string\r\n  createdAt: string\r\n  updatedAt: string\r\n  submittedAt?: string\r\n  fleetId: string\r\n}\r\n\r\nexport interface EPRFGroup {\r\n  incidentId: string\r\n  patients: EPRFRecord[]\r\n  allComplete: boolean\r\n  createdAt: string\r\n  fleetId: string\r\n}\r\n\r\nconst EPRF_HISTORY_KEY = 'eprf_history'\r\nconst EPRF_CACHE_KEY = 'eprf_cache_timestamp'\r\nconst CACHE_DURATION = 5 * 60 * 1000 // 5 minutes\r\n\r\n// Convert API record to local record format\r\nfunction apiToLocal(record: api.EPRFRecord): EPRFRecord {\r\n  return {\r\n    id: `${record.incident_id}-${record.patient_letter}`,\r\n    incidentId: record.incident_id,\r\n    patientLetter: record.patient_letter,\r\n    status: record.status as 'incomplete' | 'complete',\r\n    author: record.author_discord_id,\r\n    authorCallsign: record.author_callsign,\r\n    createdAt: record.created_at,\r\n    updatedAt: record.updated_at,\r\n    submittedAt: record.submitted_at,\r\n    fleetId: record.fleet_id\r\n  }\r\n}\r\n\r\n// Get all ePRF records for a user (async version for API)\r\nexport async function getEPRFHistoryAsync(discordId: string): Promise<EPRFRecord[]> {\r\n  try {\r\n    const apiRecords = await api.getEPRFRecordsByUser(discordId)\r\n    const records = apiRecords.map(apiToLocal)\r\n    \r\n    // Update local cache\r\n    const allRecords = getAllEPRFRecords()\r\n    const otherRecords = allRecords.filter(r => r.author !== discordId)\r\n    localStorage.setItem(EPRF_HISTORY_KEY, JSON.stringify([...otherRecords, ...records]))\r\n    localStorage.setItem(EPRF_CACHE_KEY, Date.now().toString())\r\n    \r\n    return records\r\n  } catch (error) {\r\n    console.error('Failed to fetch from API, using cache:', error)\r\n    return getEPRFHistory(discordId)\r\n  }\r\n}\r\n\r\n// Get all ePRF records for a user (sync version from cache)\r\nexport function getEPRFHistory(discordId: string): EPRFRecord[] {\r\n  try {\r\n    const data = localStorage.getItem(EPRF_HISTORY_KEY)\r\n    if (!data) return []\r\n    const allRecords: EPRFRecord[] = JSON.parse(data)\r\n    return allRecords.filter(r => r.author === discordId)\r\n  } catch {\r\n    return []\r\n  }\r\n}\r\n\r\n// Get all ePRF records (for admin purposes)\r\nexport function getAllEPRFRecords(): EPRFRecord[] {\r\n  try {\r\n    const data = localStorage.getItem(EPRF_HISTORY_KEY)\r\n    return data ? JSON.parse(data) : []\r\n  } catch {\r\n    return []\r\n  }\r\n}\r\n\r\n// Save or update an ePRF record (local cache only)\r\nexport function saveEPRFRecordLocal(record: EPRFRecord): void {\r\n  const allRecords = getAllEPRFRecords()\r\n  const existingIndex = allRecords.findIndex(\r\n    r => r.incidentId === record.incidentId && r.patientLetter === record.patientLetter\r\n  )\r\n  \r\n  if (existingIndex >= 0) {\r\n    allRecords[existingIndex] = { ...allRecords[existingIndex], ...record, updatedAt: new Date().toISOString() }\r\n  } else {\r\n    allRecords.push(record)\r\n  }\r\n  \r\n  localStorage.setItem(EPRF_HISTORY_KEY, JSON.stringify(allRecords))\r\n}\r\n\r\n// Save or update an ePRF record (API + cache)\r\nexport async function saveEPRFRecord(record: EPRFRecord): Promise<void> {\r\n  // Save to local cache first\r\n  saveEPRFRecordLocal(record)\r\n  \r\n  // Then sync to API (fire and forget for now)\r\n  try {\r\n    await api.createEPRFRecord(\r\n      record.incidentId,\r\n      record.patientLetter,\r\n      record.author,\r\n      record.authorCallsign,\r\n      record.fleetId\r\n    )\r\n  } catch (error) {\r\n    console.error('Failed to sync to API:', error)\r\n  }\r\n}\r\n\r\n// Create a new ePRF record (async version)\r\nexport async function createEPRFRecordAsync(\r\n  incidentId: string, \r\n  patientLetter: string, \r\n  authorDiscordId: string, \r\n  authorCallsign: string,\r\n  fleetId: string\r\n): Promise<EPRFRecord> {\r\n  const now = new Date().toISOString()\r\n  const record: EPRFRecord = {\r\n    id: `${incidentId}-${patientLetter}`,\r\n    incidentId,\r\n    patientLetter,\r\n    status: 'incomplete',\r\n    author: authorDiscordId,\r\n    authorCallsign,\r\n    createdAt: now,\r\n    updatedAt: now,\r\n    fleetId\r\n  }\r\n  \r\n  // Save to local cache\r\n  saveEPRFRecordLocal(record)\r\n  \r\n  // Save to API\r\n  try {\r\n    await api.createEPRFRecord(incidentId, patientLetter, authorDiscordId, authorCallsign, fleetId)\r\n  } catch (error) {\r\n    console.error('Failed to save to API:', error)\r\n  }\r\n  \r\n  return record\r\n}\r\n\r\n// Create a new ePRF record (sync version - uses local cache)\r\nexport function createEPRFRecord(\r\n  incidentId: string, \r\n  patientLetter: string, \r\n  authorDiscordId: string, \r\n  authorCallsign: string,\r\n  fleetId: string\r\n): EPRFRecord {\r\n  const now = new Date().toISOString()\r\n  const record: EPRFRecord = {\r\n    id: `${incidentId}-${patientLetter}`,\r\n    incidentId,\r\n    patientLetter,\r\n    status: 'incomplete',\r\n    author: authorDiscordId,\r\n    authorCallsign,\r\n    createdAt: now,\r\n    updatedAt: now,\r\n    fleetId\r\n  }\r\n  saveEPRFRecordLocal(record)\r\n  \r\n  // Fire and forget API call\r\n  api.createEPRFRecord(incidentId, patientLetter, authorDiscordId, authorCallsign, fleetId)\r\n    .catch(err => console.error('Failed to sync to API:', err))\r\n  \r\n  return record\r\n}\r\n\r\n// Mark an ePRF as complete (async version)\r\nexport async function markEPRFCompleteAsync(incidentId: string, patientLetter: string): Promise<void> {\r\n  // Update local cache\r\n  markEPRFCompleteLocal(incidentId, patientLetter)\r\n  \r\n  // Update via API\r\n  try {\r\n    await api.markEPRFComplete(incidentId, patientLetter)\r\n  } catch (error) {\r\n    console.error('Failed to mark complete via API:', error)\r\n  }\r\n}\r\n\r\n// Mark an ePRF as complete (local only)\r\nfunction markEPRFCompleteLocal(incidentId: string, patientLetter: string): void {\r\n  const allRecords = getAllEPRFRecords()\r\n  const record = allRecords.find(\r\n    r => r.incidentId === incidentId && r.patientLetter === patientLetter\r\n  )\r\n  \r\n  if (record) {\r\n    record.status = 'complete'\r\n    record.submittedAt = new Date().toISOString()\r\n    record.updatedAt = new Date().toISOString()\r\n    localStorage.setItem(EPRF_HISTORY_KEY, JSON.stringify(allRecords))\r\n  }\r\n}\r\n\r\n// Mark an ePRF as complete (sync version with fire-and-forget API)\r\nexport function markEPRFComplete(incidentId: string, patientLetter: string): void {\r\n  markEPRFCompleteLocal(incidentId, patientLetter)\r\n  \r\n  // Fire and forget API call\r\n  api.markEPRFComplete(incidentId, patientLetter)\r\n    .catch(err => console.error('Failed to sync to API:', err))\r\n}\r\n\r\n// Delete an ePRF record (async version)\r\nexport async function deleteEPRFRecordAsync(incidentId: string, patientLetter: string): Promise<boolean> {\r\n  // Delete from local cache first\r\n  const localSuccess = deleteEPRFRecordLocal(incidentId, patientLetter)\r\n  \r\n  // Delete via API\r\n  try {\r\n    await api.deleteEPRFRecord(incidentId, patientLetter)\r\n    return true\r\n  } catch (error) {\r\n    console.error('Failed to delete via API:', error)\r\n    return localSuccess\r\n  }\r\n}\r\n\r\n// Delete an ePRF record (local only)\r\nfunction deleteEPRFRecordLocal(incidentId: string, patientLetter: string): boolean {\r\n  const allRecords = getAllEPRFRecords()\r\n  const record = allRecords.find(\r\n    r => r.incidentId === incidentId && r.patientLetter === patientLetter\r\n  )\r\n  \r\n  if (record && record.status === 'incomplete') {\r\n    const filtered = allRecords.filter(\r\n      r => !(r.incidentId === incidentId && r.patientLetter === patientLetter)\r\n    )\r\n    localStorage.setItem(EPRF_HISTORY_KEY, JSON.stringify(filtered))\r\n    clearEPRFData(incidentId)\r\n    return true\r\n  }\r\n  return false\r\n}\r\n\r\n// Delete an ePRF record (sync version with fire-and-forget API)\r\nexport function deleteEPRFRecord(incidentId: string, patientLetter: string): boolean {\r\n  const success = deleteEPRFRecordLocal(incidentId, patientLetter)\r\n  \r\n  // Fire and forget API call\r\n  api.deleteEPRFRecord(incidentId, patientLetter)\r\n    .catch(err => console.error('Failed to sync delete to API:', err))\r\n  \r\n  return success\r\n}\r\n\r\n// Clear all localStorage data for an ePRF\r\nfunction clearEPRFData(incidentId: string): void {\r\n  const keys = [\r\n    'incident',\r\n    'patient_info',\r\n    'primary_survey',\r\n    'hx_complaint',\r\n    'past_medical_history',\r\n    'clinical_impression',\r\n    'disposition',\r\n    'vitals',\r\n    'medications',\r\n    'interventions',\r\n    'media'\r\n  ]\r\n  \r\n  keys.forEach(key => {\r\n    localStorage.removeItem(`${key}_${incidentId}`)\r\n  })\r\n}\r\n\r\n// Transfer ePRF to another user (async version)\r\nexport async function transferEPRFAsync(\r\n  incidentId: string, \r\n  patientLetter: string, \r\n  newAuthorDiscordId: string,\r\n  newAuthorCallsign: string\r\n): Promise<boolean> {\r\n  // Update local cache\r\n  transferEPRFLocal(incidentId, patientLetter, newAuthorDiscordId, newAuthorCallsign)\r\n  \r\n  // Update via API\r\n  try {\r\n    await api.transferEPRF(incidentId, patientLetter, newAuthorDiscordId, newAuthorCallsign)\r\n    return true\r\n  } catch (error) {\r\n    console.error('Failed to transfer via API:', error)\r\n    return true // Still return true since local succeeded\r\n  }\r\n}\r\n\r\n// Transfer ePRF to another user (local only)\r\nfunction transferEPRFLocal(\r\n  incidentId: string, \r\n  patientLetter: string, \r\n  newAuthorDiscordId: string,\r\n  newAuthorCallsign: string\r\n): boolean {\r\n  const allRecords = getAllEPRFRecords()\r\n  const record = allRecords.find(\r\n    r => r.incidentId === incidentId && r.patientLetter === patientLetter\r\n  )\r\n  \r\n  if (record) {\r\n    record.author = newAuthorDiscordId\r\n    record.authorCallsign = newAuthorCallsign\r\n    record.updatedAt = new Date().toISOString()\r\n    localStorage.setItem(EPRF_HISTORY_KEY, JSON.stringify(allRecords))\r\n    return true\r\n  }\r\n  return false\r\n}\r\n\r\n// Transfer ePRF (sync version with fire-and-forget API)\r\nexport function transferEPRF(\r\n  incidentId: string, \r\n  patientLetter: string, \r\n  newAuthorDiscordId: string,\r\n  newAuthorCallsign: string\r\n): boolean {\r\n  const success = transferEPRFLocal(incidentId, patientLetter, newAuthorDiscordId, newAuthorCallsign)\r\n  \r\n  // Fire and forget API call\r\n  api.transferEPRF(incidentId, patientLetter, newAuthorDiscordId, newAuthorCallsign)\r\n    .catch(err => console.error('Failed to sync transfer to API:', err))\r\n  \r\n  return success\r\n}\r\n\r\n// Transfer all patients for an incident to another user (async version)\r\nexport async function transferAllPatientsAsync(\r\n  incidentId: string,\r\n  newAuthorDiscordId: string,\r\n  newAuthorCallsign: string\r\n): Promise<boolean> {\r\n  const allRecords = getAllEPRFRecords()\r\n  const incidentRecords = allRecords.filter(r => r.incidentId === incidentId)\r\n  \r\n  if (incidentRecords.length === 0) return false\r\n  \r\n  // Transfer each patient\r\n  for (const record of incidentRecords) {\r\n    await transferEPRFAsync(incidentId, record.patientLetter, newAuthorDiscordId, newAuthorCallsign)\r\n  }\r\n  \r\n  return true\r\n}\r\n\r\n// Transfer all patients for an incident (sync version)\r\nexport function transferAllPatients(\r\n  incidentId: string,\r\n  newAuthorDiscordId: string,\r\n  newAuthorCallsign: string\r\n): boolean {\r\n  const allRecords = getAllEPRFRecords()\r\n  const incidentRecords = allRecords.filter(r => r.incidentId === incidentId)\r\n  \r\n  if (incidentRecords.length === 0) return false\r\n  \r\n  // Transfer each patient locally and fire API calls\r\n  incidentRecords.forEach(record => {\r\n    transferEPRF(incidentId, record.patientLetter, newAuthorDiscordId, newAuthorCallsign)\r\n  })\r\n  \r\n  return true\r\n}\r\n\r\n// Search ePRFs with async API fetch\r\nexport async function searchEPRFsAsync(\r\n  discordId: string, \r\n  query?: string, \r\n  status?: string\r\n): Promise<EPRFRecord[]> {\r\n  try {\r\n    const apiRecords = await api.searchEPRFs(discordId, query, status)\r\n    return apiRecords.map(apiToLocal)\r\n  } catch (error) {\r\n    console.error('Failed to search via API, using local cache:', error)\r\n    return searchEPRFs(discordId, query || '', { status: status as any })\r\n  }\r\n}\r\n\r\n// Group ePRFs by incident\r\nexport function groupEPRFsByIncident(records: EPRFRecord[]): EPRFGroup[] {\r\n  const groups: { [key: string]: EPRFRecord[] } = {}\r\n  \r\n  records.forEach(record => {\r\n    if (!groups[record.incidentId]) {\r\n      groups[record.incidentId] = []\r\n    }\r\n    groups[record.incidentId].push(record)\r\n  })\r\n  \r\n  return Object.entries(groups).map(([incidentId, patients]) => ({\r\n    incidentId,\r\n    patients: patients.sort((a, b) => a.patientLetter.localeCompare(b.patientLetter)),\r\n    allComplete: patients.every(p => p.status === 'complete'),\r\n    createdAt: patients[0]?.createdAt || '',\r\n    fleetId: patients[0]?.fleetId || ''\r\n  })).sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())\r\n}\r\n\r\n// Check if all patients for an incident are complete\r\nexport function areAllPatientsComplete(incidentId: string): boolean {\r\n  const allRecords = getAllEPRFRecords()\r\n  const incidentRecords = allRecords.filter(r => r.incidentId === incidentId)\r\n  return incidentRecords.length > 0 && incidentRecords.every(r => r.status === 'complete')\r\n}\r\n\r\n// Get incomplete ePRFs for current user\r\nexport function getIncompleteEPRFs(discordId: string): EPRFRecord[] {\r\n  return getEPRFHistory(discordId).filter(r => r.status === 'incomplete')\r\n}\r\n\r\n// Get complete ePRFs for current user\r\nexport function getCompleteEPRFs(discordId: string): EPRFRecord[] {\r\n  return getEPRFHistory(discordId).filter(r => r.status === 'complete')\r\n}\r\n\r\n// Search/filter ePRFs\r\nexport function searchEPRFs(\r\n  discordId: string, \r\n  query: string, \r\n  filters?: {\r\n    status?: 'incomplete' | 'complete' | 'all'\r\n    dateFrom?: string\r\n    dateTo?: string\r\n  }\r\n): EPRFRecord[] {\r\n  let records = getEPRFHistory(discordId)\r\n  \r\n  // Apply status filter\r\n  if (filters?.status && filters.status !== 'all') {\r\n    records = records.filter(r => r.status === filters.status)\r\n  }\r\n  \r\n  // Apply date filters\r\n  if (filters?.dateFrom) {\r\n    const fromDate = new Date(filters.dateFrom).getTime()\r\n    records = records.filter(r => new Date(r.createdAt).getTime() >= fromDate)\r\n  }\r\n  \r\n  if (filters?.dateTo) {\r\n    const toDate = new Date(filters.dateTo).getTime() + (24 * 60 * 60 * 1000) // Include full day\r\n    records = records.filter(r => new Date(r.createdAt).getTime() <= toDate)\r\n  }\r\n  \r\n  // Apply search query\r\n  if (query.trim()) {\r\n    const q = query.toLowerCase()\r\n    records = records.filter(r => \r\n      r.incidentId.toLowerCase().includes(q) ||\r\n      r.patientLetter.toLowerCase().includes(q) ||\r\n      r.authorCallsign.toLowerCase().includes(q)\r\n    )\r\n  }\r\n  \r\n  return records\r\n}\r\n\r\n// Get record by incident and patient\r\nexport function getEPRFRecord(incidentId: string, patientLetter: string): EPRFRecord | null {\r\n  const allRecords = getAllEPRFRecords()\r\n  return allRecords.find(\r\n    r => r.incidentId === incidentId && r.patientLetter === patientLetter\r\n  ) || null\r\n}\r\n\r\n// Check if user has any incomplete multi-patient ePRFs that can't be submitted\r\nexport function getBlockedSubmissions(discordId: string): EPRFGroup[] {\r\n  const records = getEPRFHistory(discordId)\r\n  const groups = groupEPRFsByIncident(records)\r\n  \r\n  return groups.filter(group => \r\n    group.patients.length > 1 && \r\n    !group.allComplete && \r\n    group.patients.some(p => p.status === 'complete')\r\n  )\r\n}\r\n","'use client'\r\n\r\nimport { validateAllSections, ValidationResult } from './validation'\r\nimport { collectEPRFData, downloadEPRFPdf } from './pdfGenerator'\r\n\r\n// Get the current patient letter from localStorage or default to 'A'\r\nexport function getCurrentPatientLetter(incidentId: string): string {\r\n  try {\r\n    const letter = localStorage.getItem(`patient_letter_${incidentId}`)\r\n    return letter || 'A'\r\n  } catch {\r\n    return 'A'\r\n  }\r\n}\r\n\r\n// Set the current patient letter\r\nexport function setCurrentPatientLetter(incidentId: string, letter: string): void {\r\n  localStorage.setItem(`patient_letter_${incidentId}`, letter)\r\n}\r\n\r\n// Get all saved patients for an incident\r\nexport function getSavedPatients(incidentId: string): string[] {\r\n  try {\r\n    const data = localStorage.getItem(`saved_patients_${incidentId}`)\r\n    return data ? JSON.parse(data) : []\r\n  } catch {\r\n    return []\r\n  }\r\n}\r\n\r\n// Add a patient to the saved patients list\r\nfunction addSavedPatient(incidentId: string, letter: string): void {\r\n  const patients = getSavedPatients(incidentId)\r\n  if (!patients.includes(letter)) {\r\n    patients.push(letter)\r\n    localStorage.setItem(`saved_patients_${incidentId}`, JSON.stringify(patients))\r\n  }\r\n}\r\n\r\n// Get the next patient letter (A -> B -> C, etc.)\r\nexport function getNextPatientLetter(currentLetter: string): string {\r\n  const code = currentLetter.charCodeAt(0)\r\n  // Support up to Z (26 patients)\r\n  if (code >= 90) return 'Z' // Already at Z\r\n  return String.fromCharCode(code + 1)\r\n}\r\n\r\n// Archive current patient data with the patient letter suffix\r\nfunction archivePatientData(incidentId: string, patientLetter: string): void {\r\n  const keys = [\r\n    'patient_info',\r\n    'primary_survey',\r\n    'hx_complaint',\r\n    'past_medical_history',\r\n    'clinical_impression',\r\n    'disposition',\r\n    'vitals',\r\n    'medications',\r\n    'interventions'\r\n  ]\r\n  \r\n  keys.forEach(key => {\r\n    const currentKey = `${key}_${incidentId}`\r\n    const archiveKey = `${key}_${incidentId}_${patientLetter}`\r\n    const data = localStorage.getItem(currentKey)\r\n    if (data) {\r\n      localStorage.setItem(archiveKey, data)\r\n    }\r\n  })\r\n}\r\n\r\n// Clear patient-specific data (not incident data)\r\nfunction clearPatientData(incidentId: string): void {\r\n  const keys = [\r\n    'patient_info',\r\n    'primary_survey',\r\n    'hx_complaint',\r\n    'past_medical_history',\r\n    'clinical_impression',\r\n    'disposition',\r\n    'vitals',\r\n    'medications',\r\n    'interventions'\r\n  ]\r\n  \r\n  keys.forEach(key => {\r\n    localStorage.removeItem(`${key}_${incidentId}`)\r\n  })\r\n  \r\n  // Also clear any draft data\r\n  const draftKeys = [\r\n    'vitals_draft',\r\n    'medications_draft',\r\n    'interventions_draft'\r\n  ]\r\n  \r\n  draftKeys.forEach(key => {\r\n    localStorage.removeItem(`${key}_${incidentId}`)\r\n  })\r\n}\r\n\r\n// Add Patient: Archive current, move to next letter, clear form\r\nexport async function handleAddPatient(incidentId: string): Promise<{ success: boolean; newLetter: string; error?: string }> {\r\n  try {\r\n    const currentLetter = getCurrentPatientLetter(incidentId)\r\n    \r\n    // Archive current patient data\r\n    archivePatientData(incidentId, currentLetter)\r\n    \r\n    // Add to saved patients list\r\n    addSavedPatient(incidentId, currentLetter)\r\n    \r\n    // Get next letter\r\n    const nextLetter = getNextPatientLetter(currentLetter)\r\n    \r\n    // Set the new patient letter\r\n    setCurrentPatientLetter(incidentId, nextLetter)\r\n    \r\n    // Clear patient-specific data for the new patient\r\n    clearPatientData(incidentId)\r\n    \r\n    return { success: true, newLetter: nextLetter }\r\n  } catch (error) {\r\n    console.error('Error adding patient:', error)\r\n    return { success: false, newLetter: '', error: 'Failed to add patient' }\r\n  }\r\n}\r\n\r\n// Submit ePRF: Validate, generate PDF, save to database\r\nexport async function handleSubmitEPRF(incidentId: string, fleetId: string): Promise<{ \r\n  success: boolean; \r\n  validationResult?: ValidationResult;\r\n  error?: string \r\n}> {\r\n  try {\r\n    // First validate all sections\r\n    const validationResult = validateAllSections(incidentId)\r\n    \r\n    if (!validationResult.isValid) {\r\n      return { \r\n        success: false, \r\n        validationResult,\r\n        error: 'Please complete all required fields before submitting' \r\n      }\r\n    }\r\n    \r\n    const currentLetter = getCurrentPatientLetter(incidentId)\r\n    \r\n    // Collect all ePRF data\r\n    const eprfData = collectEPRFData(incidentId, currentLetter)\r\n    \r\n    // Generate and download PDF\r\n    downloadEPRFPdf(eprfData)\r\n    \r\n    // Save to database\r\n    try {\r\n      const response = await fetch('/api/eprf/submit', {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({\r\n          incidentId,\r\n          fleetId,\r\n          patientLetter: currentLetter,\r\n          data: eprfData,\r\n          submittedAt: new Date().toISOString()\r\n        })\r\n      })\r\n      \r\n      if (!response.ok) {\r\n        console.warn('Database save failed, but PDF was downloaded')\r\n      }\r\n    } catch (dbError) {\r\n      console.warn('Database save failed, but PDF was downloaded:', dbError)\r\n      // Don't fail the whole operation if DB save fails\r\n    }\r\n    \r\n    // Archive this patient's data\r\n    archivePatientData(incidentId, currentLetter)\r\n    addSavedPatient(incidentId, currentLetter)\r\n    \r\n    return { success: true }\r\n  } catch (error) {\r\n    console.error('Error submitting ePRF:', error)\r\n    return { success: false, error: 'Failed to submit ePRF' }\r\n  }\r\n}\r\n\r\n// Get all patient data for an incident (for viewing/editing previous patients)\r\nexport function getPatientData(incidentId: string, patientLetter: string): any {\r\n  const keys = [\r\n    'patient_info',\r\n    'primary_survey',\r\n    'hx_complaint',\r\n    'past_medical_history',\r\n    'clinical_impression',\r\n    'disposition',\r\n    'vitals',\r\n    'medications',\r\n    'interventions'\r\n  ]\r\n  \r\n  const data: any = {}\r\n  \r\n  keys.forEach(key => {\r\n    const archiveKey = `${key}_${incidentId}_${patientLetter}`\r\n    const stored = localStorage.getItem(archiveKey)\r\n    if (stored) {\r\n      try {\r\n        data[key] = JSON.parse(stored)\r\n      } catch {\r\n        data[key] = null\r\n      }\r\n    }\r\n  })\r\n  \r\n  return data\r\n}\r\n","'use client'\r\n\r\n// User session management service\r\n// Now syncs with database API for cross-device user visibility\r\n\r\nimport * as api from './apiClient'\r\n\r\nexport interface User {\r\n  discordId: string\r\n  discordUsername?: string\r\n  callsign: string\r\n  vehicle: string\r\n  loginTime: string\r\n}\r\n\r\nconst USERS_KEY = 'logged_in_users'\r\nconst CURRENT_USER_KEY = 'current_user'\r\n\r\n// Get all currently logged in users\r\nexport function getLoggedInUsers(): User[] {\r\n  try {\r\n    const data = localStorage.getItem(USERS_KEY)\r\n    if (!data) return []\r\n    const users = JSON.parse(data)\r\n    // Filter out users who logged in more than 24 hours ago\r\n    const now = new Date().getTime()\r\n    const dayInMs = 24 * 60 * 60 * 1000\r\n    return users.filter((user: User) => {\r\n      const loginTime = new Date(user.loginTime).getTime()\r\n      return now - loginTime < dayInMs\r\n    })\r\n  } catch {\r\n    return []\r\n  }\r\n}\r\n\r\n// Add a user to the logged in list\r\nexport function addLoggedInUser(user: User): void {\r\n  const users = getLoggedInUsers()\r\n  // Remove existing entry for same user\r\n  const filtered = users.filter(u => u.discordId !== user.discordId)\r\n  filtered.push(user)\r\n  localStorage.setItem(USERS_KEY, JSON.stringify(filtered))\r\n}\r\n\r\n// Remove a user from the logged in list\r\nexport function removeLoggedInUser(discordId: string): void {\r\n  const users = getLoggedInUsers()\r\n  const filtered = users.filter(u => u.discordId !== discordId)\r\n  localStorage.setItem(USERS_KEY, JSON.stringify(filtered))\r\n}\r\n\r\n// Get current user\r\nexport function getCurrentUser(): User | null {\r\n  try {\r\n    const data = localStorage.getItem(CURRENT_USER_KEY)\r\n    return data ? JSON.parse(data) : null\r\n  } catch {\r\n    return null\r\n  }\r\n}\r\n\r\n// Set current user (also syncs to API)\r\nexport function setCurrentUser(user: User): void {\r\n  localStorage.setItem(CURRENT_USER_KEY, JSON.stringify(user))\r\n  addLoggedInUser(user)\r\n  \r\n  // Fire and forget API call to register user login\r\n  api.loginUser(\r\n    user.discordId,\r\n    user.discordUsername || '',\r\n    user.callsign,\r\n    user.vehicle\r\n  ).catch(err => console.error('Failed to sync user login to API:', err))\r\n}\r\n\r\n// Async version for when you need to wait for API\r\nexport async function setCurrentUserAsync(user: User): Promise<void> {\r\n  localStorage.setItem(CURRENT_USER_KEY, JSON.stringify(user))\r\n  addLoggedInUser(user)\r\n  \r\n  try {\r\n    await api.loginUser(\r\n      user.discordId,\r\n      user.discordUsername || '',\r\n      user.callsign,\r\n      user.vehicle\r\n    )\r\n  } catch (err) {\r\n    console.error('Failed to sync user login to API:', err)\r\n  }\r\n}\r\n\r\n// Clear current user (logout)\r\nexport function clearCurrentUser(): void {\r\n  const current = getCurrentUser()\r\n  if (current) {\r\n    removeLoggedInUser(current.discordId)\r\n  }\r\n  localStorage.removeItem(CURRENT_USER_KEY)\r\n}\r\n\r\n// Get other logged in users (excluding current)\r\nexport function getOtherLoggedInUsers(): User[] {\r\n  const current = getCurrentUser()\r\n  if (!current) return getLoggedInUsers()\r\n  return getLoggedInUsers().filter(u => u.discordId !== current.discordId)\r\n}\r\n\r\n// Get other logged in users from API (async)\r\nexport async function getOtherLoggedInUsersAsync(): Promise<User[]> {\r\n  try {\r\n    const current = getCurrentUser()\r\n    const apiUsers = await api.getActiveUsers()\r\n    \r\n    return apiUsers\r\n      .filter(u => u.discord_id !== current?.discordId)\r\n      .map(u => ({\r\n        discordId: u.discord_id,\r\n        discordUsername: u.discord_username,\r\n        callsign: u.callsign,\r\n        vehicle: u.vehicle,\r\n        loginTime: u.last_login\r\n      }))\r\n  } catch (error) {\r\n    console.error('Failed to get users from API:', error)\r\n    return getOtherLoggedInUsers()\r\n  }\r\n}\r\n","// Validation utility for ePRF submission\r\n\r\nexport interface ValidationResult {\r\n  isValid: boolean\r\n  incompleteSections: string[]\r\n  fieldErrors: { [section: string]: string[] }\r\n}\r\n\r\n// Map section names to localStorage key prefixes\r\nconst STORAGE_KEY_MAP: { [key: string]: string } = {\r\n  'incident': 'incident',\r\n  'patient-info': 'patient_info',\r\n  'primary-survey': 'primary_survey',\r\n  'hx-complaint': 'hx_complaint',\r\n  'past-medical-history': 'past_medical_history',\r\n  'clinical-impression': 'clinical_impression',\r\n  'disposition': 'disposition'\r\n}\r\n\r\n// Required fields for each section\r\nexport const REQUIRED_FIELDS = {\r\n  incident: {\r\n    fields: ['caseType', 'dateTimeOfCall', 'incidentLocation', 'locationType'],\r\n    labels: {\r\n      caseType: 'Case Type',\r\n      dateTimeOfCall: 'Date/Time of Call',\r\n      incidentLocation: 'Incident Location',\r\n      locationType: 'Location Type'\r\n    }\r\n  },\r\n  'patient-info': {\r\n    fields: ['robloxUsername', 'firstName', 'surname', 'sex', 'dob', 'age', 'ageType', 'ptAddress'],\r\n    labels: {\r\n      robloxUsername: 'Roblox Username',\r\n      firstName: 'First Name',\r\n      surname: 'Family Name (surname)',\r\n      sex: 'Sex',\r\n      dob: 'Date of Birth',\r\n      age: 'Age',\r\n      ageType: 'Age Type',\r\n      ptAddress: 'Patient Address'\r\n    }\r\n  },\r\n  'primary-survey': {\r\n    fields: ['clinicalStatus', 'responsiveness', 'airway', 'breathing', 'circulation', 'bloodLoss'],\r\n    labels: {\r\n      clinicalStatus: 'Clinical Status at Scene',\r\n      responsiveness: 'Responsiveness',\r\n      airway: 'Airway',\r\n      breathing: 'Breathing',\r\n      circulation: 'Circulation',\r\n      bloodLoss: 'Blood Loss'\r\n    }\r\n  },\r\n  'hx-complaint': {\r\n    fields: ['complaints', 'dateOfOnset'],\r\n    labels: {\r\n      complaints: 'Presenting Complaint',\r\n      dateOfOnset: 'Date of Onset'\r\n    }\r\n  },\r\n  'past-medical-history': {\r\n    fields: ['pastMedicalHistory', 'medications', 'allergies', 'lastOralIntake'],\r\n    labels: {\r\n      pastMedicalHistory: 'Past Medical History',\r\n      medications: 'Medications',\r\n      allergies: 'Allergies',\r\n      lastOralIntake: 'Last Oral Intake'\r\n    }\r\n  },\r\n  'clinical-impression': {\r\n    fields: ['primaryClinicalImpression'],\r\n    labels: {\r\n      primaryClinicalImpression: 'Primary Clinical Impression'\r\n    }\r\n  },\r\n  disposition: {\r\n    fields: ['disposition', 'finalPatientStatus', 'copyToGP'],\r\n    labels: {\r\n      disposition: 'Disposition',\r\n      finalPatientStatus: 'Final Patient Status',\r\n      copyToGP: 'Copy to GP?'\r\n    }\r\n  }\r\n}\r\n\r\n// Required fields for vitals entries (when an entry is made)\r\nexport const VITALS_REQUIRED_FIELDS = {\r\n  time: 'Time'\r\n}\r\n\r\n// Required fields for medication entries (when an entry is made)\r\nexport const MEDICATION_REQUIRED_FIELDS = {\r\n  time: 'Time',\r\n  administeredBy: 'Administered by',\r\n  medication: 'Medication',\r\n  dose: 'Dose',\r\n  unit: 'Unit',\r\n  route: 'Route'\r\n}\r\n\r\n// Required fields for intervention entries (when an entry is made)\r\nexport const INTERVENTION_REQUIRED_FIELDS = {\r\n  time: 'Time',\r\n  performedBy: 'Performed by'\r\n}\r\n\r\n// Get localStorage key for a section\r\nfunction getStorageKey(sectionName: string, incidentId: string): string {\r\n  const prefix = STORAGE_KEY_MAP[sectionName] || sectionName.replace(/-/g, '_')\r\n  return `${prefix}_${incidentId}`\r\n}\r\n\r\n// Validate a single section from localStorage\r\nexport function validateSection(sectionName: string, incidentId: string): string[] {\r\n  const errors: string[] = []\r\n  const config = REQUIRED_FIELDS[sectionName as keyof typeof REQUIRED_FIELDS]\r\n  \r\n  if (!config) return errors\r\n  \r\n  try {\r\n    const storageKey = getStorageKey(sectionName, incidentId)\r\n    const data = localStorage.getItem(storageKey)\r\n    if (!data) {\r\n      // If no data at all, all required fields are missing\r\n      return config.fields.map(field => config.labels[field as keyof typeof config.labels])\r\n    }\r\n    \r\n    const parsed = JSON.parse(data)\r\n    \r\n    for (const field of config.fields) {\r\n      const value = parsed[field]\r\n      // Handle arrays (like complaints) - check if empty\r\n      if (Array.isArray(value)) {\r\n        if (value.length === 0) {\r\n          errors.push(config.labels[field as keyof typeof config.labels])\r\n        }\r\n      } else if (!value || (typeof value === 'string' && value.trim() === '')) {\r\n        errors.push(config.labels[field as keyof typeof config.labels])\r\n      }\r\n    }\r\n  } catch (e) {\r\n    console.error(`Error validating ${sectionName}:`, e)\r\n  }\r\n  \r\n  return errors\r\n}\r\n\r\n// Validate all sections\r\nexport function validateAllSections(incidentId: string): ValidationResult {\r\n  const incompleteSections: string[] = []\r\n  const fieldErrors: { [section: string]: string[] } = {}\r\n  \r\n  for (const sectionName of Object.keys(REQUIRED_FIELDS)) {\r\n    const errors = validateSection(sectionName, incidentId)\r\n    if (errors.length > 0) {\r\n      incompleteSections.push(sectionName)\r\n      fieldErrors[sectionName] = errors\r\n    }\r\n  }\r\n  \r\n  // Also check for vitals entries that have incomplete required fields\r\n  try {\r\n    const vitalsData = localStorage.getItem(`vitals_${incidentId}`)\r\n    if (vitalsData) {\r\n      const vitals = JSON.parse(vitalsData)\r\n      if (Array.isArray(vitals) && vitals.length > 0) {\r\n        for (const entry of vitals) {\r\n          if (!entry.time || entry.time.trim() === '') {\r\n            if (!incompleteSections.includes('vital-obs')) {\r\n              incompleteSections.push('vital-obs')\r\n            }\r\n            if (!fieldErrors['vital-obs']) {\r\n              fieldErrors['vital-obs'] = []\r\n            }\r\n            if (!fieldErrors['vital-obs'].includes('Vitals entry missing Time')) {\r\n              fieldErrors['vital-obs'].push('Vitals entry missing Time')\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  } catch (e) {\r\n    console.error('Error validating vitals:', e)\r\n  }\r\n  \r\n  // Check medication entries\r\n  try {\r\n    const medsData = localStorage.getItem(`medications_${incidentId}`)\r\n    if (medsData) {\r\n      const meds = JSON.parse(medsData)\r\n      if (Array.isArray(meds) && meds.length > 0) {\r\n        for (const entry of meds) {\r\n          const missingFields: string[] = []\r\n          if (!entry.time) missingFields.push('Time')\r\n          if (!entry.administeredBy) missingFields.push('Administered by')\r\n          if (!entry.medication) missingFields.push('Medication')\r\n          if (!entry.dose) missingFields.push('Dose')\r\n          if (!entry.unit) missingFields.push('Unit')\r\n          if (!entry.route) missingFields.push('Route')\r\n          \r\n          if (missingFields.length > 0) {\r\n            if (!incompleteSections.includes('medications')) {\r\n              incompleteSections.push('medications')\r\n            }\r\n            if (!fieldErrors['medications']) {\r\n              fieldErrors['medications'] = []\r\n            }\r\n            fieldErrors['medications'].push(`Medication entry missing: ${missingFields.join(', ')}`)\r\n          }\r\n        }\r\n      }\r\n    }\r\n  } catch (e) {\r\n    console.error('Error validating medications:', e)\r\n  }\r\n  \r\n  // Check intervention entries\r\n  try {\r\n    const interventionsData = localStorage.getItem(`interventions_${incidentId}`)\r\n    if (interventionsData) {\r\n      const interventions = JSON.parse(interventionsData)\r\n      if (Array.isArray(interventions) && interventions.length > 0) {\r\n        for (const entry of interventions) {\r\n          const missingFields: string[] = []\r\n          if (!entry.time) missingFields.push('Time')\r\n          if (!entry.performedBy) missingFields.push('Performed by')\r\n          \r\n          if (missingFields.length > 0) {\r\n            if (!incompleteSections.includes('interventions')) {\r\n              incompleteSections.push('interventions')\r\n            }\r\n            if (!fieldErrors['interventions']) {\r\n              fieldErrors['interventions'] = []\r\n            }\r\n            fieldErrors['interventions'].push(`Intervention entry missing: ${missingFields.join(', ')}`)\r\n          }\r\n        }\r\n      }\r\n    }\r\n  } catch (e) {\r\n    console.error('Error validating interventions:', e)\r\n  }\r\n  \r\n  return {\r\n    isValid: incompleteSections.length === 0,\r\n    incompleteSections,\r\n    fieldErrors\r\n  }\r\n}\r\n\r\n// Get section display name\r\nexport function getSectionDisplayName(section: string): string {\r\n  const names: { [key: string]: string } = {\r\n    'incident': 'Incident Information',\r\n    'patient-info': 'Patient Information',\r\n    'primary-survey': 'Primary Survey',\r\n    'vital-obs': 'Vital Obs / Treat',\r\n    'hx-complaint': 'Hx Complaint',\r\n    'past-medical-history': 'Past Medical History',\r\n    'clinical-impression': 'Clinical Impression',\r\n    'disposition': 'Disposition',\r\n    'media': 'Media',\r\n    'medications': 'Medications',\r\n    'interventions': 'Interventions'\r\n  }\r\n  return names[section] || section\r\n}\r\n"],"names":["TransferModal","isOpen","onClose","onTransferComplete","incidentId","patientLetter","isLoading","users","setUsers","useState","selectedUser","setSelectedUser","showConfirmation","setShowConfirmation","loadingUsers","setLoadingUsers","handleUserSelect","user","transferTarget","react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__","jsxs","div","onClick","e","stopPropagation","jsx","style","position","strong","span","p","length","Fragment","marginBottom","fontSize","color","map","discordId","input","type","checked","onChange","callsign","vehicle","Date","loginTime","toLocaleTimeString","hour","minute","marginTop","br","button","disabled","EPRF_HISTORY_KEY","apiToLocal","record","id","incident_id","patient_letter","status","author","author_discord_id","authorCallsign","author_callsign","createdAt","created_at","updatedAt","updated_at","submittedAt","submitted_at","fleetId","fleet_id","getEPRFHistoryAsync","records","apiRecords","api","otherRecords","allRecords","filter","r","localStorage","setItem","JSON","stringify","now","toString","error","console","getEPRFHistory","data","getItem","parse","getAllEPRFRecords","saveEPRFRecordLocal","existingIndex","findIndex","toISOString","push","saveEPRFRecord","createEPRFRecordAsync","authorDiscordId","createEPRFRecord","catch","err","markEPRFCompleteAsync","markEPRFCompleteLocal","find","markEPRFComplete","deleteEPRFRecordAsync","localSuccess","deleteEPRFRecordLocal","filtered","keys","forEach","key","removeItem","deleteEPRFRecord","success","transferEPRFAsync","newAuthorDiscordId","newAuthorCallsign","transferEPRFLocal","transferEPRF","transferAllPatientsAsync","incidentRecords","transferAllPatients","searchEPRFsAsync","query","searchEPRFs","groupEPRFsByIncident","groups","Object","entries","patients","sort","a","b","localeCompare","allComplete","every","getTime","areAllPatientsComplete","getIncompleteEPRFs","getCompleteEPRFs","filters","dateFrom","fromDate","dateTo","toDate","trim","q","toLowerCase","includes","getEPRFRecord","getBlockedSubmissions","group","some","getCurrentPatientLetter","letter","addSavedPatient","getSavedPatients","archivePatientData","currentKey","archiveKey","handleAddPatient","currentLetter","nextLetter","getNextPatientLetter","code","charCodeAt","String","fromCharCode","draftKeys","newLetter","handleSubmitEPRF","validationResult","validateAllSections","isValid","eprfData","collectEPRFData","downloadEPRFPdf","response","fetch","method","headers","body","ok","warn","dbError","getLoggedInUsers","getCurrentUser","getOtherLoggedInUsers","current","u","STORAGE_KEY_MAP","REQUIRED_FIELDS","incident","fields","labels","caseType","dateTimeOfCall","incidentLocation","locationType","robloxUsername","firstName","surname","sex","dob","age","ageType","ptAddress","clinicalStatus","responsiveness","airway","breathing","circulation","bloodLoss","complaints","dateOfOnset","pastMedicalHistory","medications","allergies","lastOralIntake","primaryClinicalImpression","disposition","finalPatientStatus","copyToGP","incompleteSections","fieldErrors","sectionName","errors","validateSection","config","storageKey","getStorageKey","prefix","replace","field","parsed","value","Array","isArray","vitalsData","vitals","entry","time","medsData","meds","missingFields","administeredBy","medication","dose","unit","route","join","interventionsData","interventions","performedBy","getSectionDisplayName","section","names"],"sourceRoot":""}