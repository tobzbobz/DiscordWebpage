{"version":3,"file":"app/api/eprf/data/route.js","mappings":"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","sources":["webpack://_N_E/external commonjs \"node:async_hooks\"","webpack://_N_E/external commonjs \"node:buffer\"","webpack://_N_E/./app/api/eprf/data/route.js","webpack://_N_E/./app/api/eprf/data/route.js?610a","webpack://_N_E/?4fd1","webpack://_N_E/./lib/db.ts"],"sourcesContent":["module.exports = require(\"node:async_hooks\");","module.exports = require(\"node:buffer\");","import { saveEPRFData, getEPRFData, getAllEPRFData } from '../../../../lib/db';\r\n\r\nexport const runtime = 'edge';\r\n\r\n// GET - Fetch ePRF form data\r\nexport async function GET(request) {\r\n  try {\r\n    const { searchParams } = new URL(request.url);\r\n    const incidentId = searchParams.get('incidentId');\r\n    const patientLetter = searchParams.get('patientLetter');\r\n    const section = searchParams.get('section');\r\n    \r\n    if (!incidentId || !patientLetter) {\r\n      return Response.json({ success: false, error: 'Missing required parameters' }, { status: 400 });\r\n    }\r\n    \r\n    if (section) {\r\n      // Get specific section data\r\n      const data = await getEPRFData(incidentId, patientLetter, section);\r\n      return Response.json({ success: true, data });\r\n    } else {\r\n      // Get all sections\r\n      const data = await getAllEPRFData(incidentId, patientLetter);\r\n      return Response.json({ success: true, data });\r\n    }\r\n  } catch (error) {\r\n    console.error('GET ePRF data error:', error);\r\n    return Response.json({ success: false, error: error.message }, { status: 500 });\r\n  }\r\n}\r\n\r\n// POST - Save ePRF form data\r\nexport async function POST(request) {\r\n  try {\r\n    const body = await request.json();\r\n    const { incidentId, patientLetter, section, data } = body;\r\n    \r\n    if (!incidentId || !patientLetter || !section || data === undefined) {\r\n      return Response.json({ success: false, error: 'Missing required fields' }, { status: 400 });\r\n    }\r\n    \r\n    const result = await saveEPRFData(incidentId, patientLetter, section, data);\r\n    \r\n    return Response.json({ success: true, result });\r\n  } catch (error) {\r\n    console.error('POST ePRF data error:', error);\r\n    return Response.json({ success: false, error: error.message }, { status: 500 });\r\n  }\r\n}\r\n","import { AppRouteRouteModule } from \"next/dist/server/future/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/server/future/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/server/lib/patch-fetch\";\nimport * as userland from \"C:\\\\Users\\\\Toby\\\\Downloads\\\\node-v24.11.1-win-x64\\\\app123\\\\app\\\\api\\\\eprf\\\\data\\\\route.js\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/eprf/data/route\",\n        pathname: \"/api/eprf/data\",\n        filename: \"route\",\n        bundlePath: \"app/api/eprf/data/route\"\n    },\n    resolvedPagePath: \"C:\\\\Users\\\\Toby\\\\Downloads\\\\node-v24.11.1-win-x64\\\\app123\\\\app\\\\api\\\\eprf\\\\data\\\\route.js\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/eprf/data/route\";\nfunction patchFetch() {\n    return _patchFetch({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\nexport { routeModule, requestAsyncStorage, staticGenerationAsyncStorage, serverHooks, originalPathname, patchFetch,  };\n\n//# sourceMappingURL=app-route.js.map","import { EdgeRouteModuleWrapper } from \"next/dist/server/web/edge-route-module-wrapper\";\n// Import the userland code.\nimport * as module from \"next-app-loader?name=app%2Fapi%2Feprf%2Fdata%2Froute&page=%2Fapi%2Feprf%2Fdata%2Froute&pagePath=private-next-app-dir%2Fapi%2Feprf%2Fdata%2Froute.js&appDir=C%3A%5CUsers%5CToby%5CDownloads%5Cnode-v24.11.1-win-x64%5Capp123%5Capp&appPaths=%2Fapi%2Feprf%2Fdata%2Froute&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!private-next-app-dir/api/eprf/data/route.js?__next_edge_ssr_entry__\";\nexport const ComponentMod = module;\nexport default EdgeRouteModuleWrapper.wrap(module.routeModule);\n\n//# sourceMappingURL=edge-app-route.js.map","import { neon } from '@neondatabase/serverless';\r\n\r\n// Get the database connection\r\nexport function getDb() {\r\n  if (!process.env.DATABASE_URL) {\r\n    throw new Error('DATABASE_URL environment variable is not set');\r\n  }\r\n  return neon(process.env.DATABASE_URL);\r\n}\r\n\r\n// Initialize database tables\r\nexport async function initializeDatabase() {\r\n  const sql = getDb();\r\n  \r\n  // Create users table\r\n  await sql`\r\n    CREATE TABLE IF NOT EXISTS users (\r\n      id SERIAL PRIMARY KEY,\r\n      discord_id VARCHAR(255) UNIQUE NOT NULL,\r\n      discord_username VARCHAR(255),\r\n      callsign VARCHAR(100),\r\n      vehicle VARCHAR(100),\r\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n      last_login TIMESTAMP DEFAULT CURRENT_TIMESTAMP\r\n    )\r\n  `;\r\n  \r\n  // Create eprf_records table (main ePRF tracking)\r\n  await sql`\r\n    CREATE TABLE IF NOT EXISTS eprf_records (\r\n      id SERIAL PRIMARY KEY,\r\n      incident_id VARCHAR(255) NOT NULL,\r\n      patient_letter CHAR(1) NOT NULL,\r\n      status VARCHAR(20) DEFAULT 'incomplete',\r\n      author_discord_id VARCHAR(255) NOT NULL,\r\n      author_callsign VARCHAR(100),\r\n      fleet_id VARCHAR(100),\r\n      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n      submitted_at TIMESTAMP,\r\n      UNIQUE(incident_id, patient_letter)\r\n    )\r\n  `;\r\n  \r\n  // Create eprf_data table (stores all form data as JSON)\r\n  await sql`\r\n    CREATE TABLE IF NOT EXISTS eprf_data (\r\n      id SERIAL PRIMARY KEY,\r\n      incident_id VARCHAR(255) NOT NULL,\r\n      patient_letter CHAR(1) NOT NULL,\r\n      section VARCHAR(50) NOT NULL,\r\n      data JSONB NOT NULL,\r\n      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n      UNIQUE(incident_id, patient_letter, section)\r\n    )\r\n  `;\r\n  \r\n  // Create indexes for faster queries\r\n  await sql`CREATE INDEX IF NOT EXISTS idx_eprf_records_author ON eprf_records(author_discord_id)`;\r\n  await sql`CREATE INDEX IF NOT EXISTS idx_eprf_records_status ON eprf_records(status)`;\r\n  await sql`CREATE INDEX IF NOT EXISTS idx_eprf_data_incident ON eprf_data(incident_id, patient_letter)`;\r\n  \r\n  return { success: true };\r\n}\r\n\r\n// ePRF Record operations\r\nexport async function createEPRFRecord(\r\n  incidentId: string,\r\n  patientLetter: string,\r\n  authorDiscordId: string,\r\n  authorCallsign: string,\r\n  fleetId: string\r\n) {\r\n  const sql = getDb();\r\n  \r\n  const result = await sql`\r\n    INSERT INTO eprf_records (incident_id, patient_letter, author_discord_id, author_callsign, fleet_id)\r\n    VALUES (${incidentId}, ${patientLetter}, ${authorDiscordId}, ${authorCallsign}, ${fleetId})\r\n    ON CONFLICT (incident_id, patient_letter) \r\n    DO UPDATE SET updated_at = CURRENT_TIMESTAMP\r\n    RETURNING *\r\n  `;\r\n  \r\n  return result[0];\r\n}\r\n\r\nexport async function getEPRFRecord(incidentId: string, patientLetter: string) {\r\n  const sql = getDb();\r\n  \r\n  const result = await sql`\r\n    SELECT * FROM eprf_records \r\n    WHERE incident_id = ${incidentId} AND patient_letter = ${patientLetter}\r\n  `;\r\n  \r\n  return result[0] || null;\r\n}\r\n\r\nexport async function getEPRFRecordsByUser(discordId: string) {\r\n  const sql = getDb();\r\n  \r\n  const result = await sql`\r\n    SELECT * FROM eprf_records \r\n    WHERE author_discord_id = ${discordId}\r\n    ORDER BY created_at DESC\r\n  `;\r\n  \r\n  return result;\r\n}\r\n\r\nexport async function getEPRFRecordsByStatus(discordId: string, status: string) {\r\n  const sql = getDb();\r\n  \r\n  const result = await sql`\r\n    SELECT * FROM eprf_records \r\n    WHERE author_discord_id = ${discordId} AND status = ${status}\r\n    ORDER BY created_at DESC\r\n  `;\r\n  \r\n  return result;\r\n}\r\n\r\nexport async function markEPRFComplete(incidentId: string, patientLetter: string) {\r\n  const sql = getDb();\r\n  \r\n  const result = await sql`\r\n    UPDATE eprf_records \r\n    SET status = 'complete', submitted_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP\r\n    WHERE incident_id = ${incidentId} AND patient_letter = ${patientLetter}\r\n    RETURNING *\r\n  `;\r\n  \r\n  return result[0];\r\n}\r\n\r\nexport async function deleteEPRFRecord(incidentId: string, patientLetter: string) {\r\n  const sql = getDb();\r\n  \r\n  // Delete data first (foreign key would normally handle this)\r\n  await sql`\r\n    DELETE FROM eprf_data \r\n    WHERE incident_id = ${incidentId} AND patient_letter = ${patientLetter}\r\n  `;\r\n  \r\n  // Then delete the record\r\n  const result = await sql`\r\n    DELETE FROM eprf_records \r\n    WHERE incident_id = ${incidentId} AND patient_letter = ${patientLetter}\r\n    AND status = 'incomplete'\r\n    RETURNING *\r\n  `;\r\n  \r\n  return result[0] || null;\r\n}\r\n\r\nexport async function transferEPRF(\r\n  incidentId: string,\r\n  patientLetter: string,\r\n  newAuthorDiscordId: string,\r\n  newAuthorCallsign: string\r\n) {\r\n  const sql = getDb();\r\n  \r\n  const result = await sql`\r\n    UPDATE eprf_records \r\n    SET author_discord_id = ${newAuthorDiscordId}, \r\n        author_callsign = ${newAuthorCallsign},\r\n        updated_at = CURRENT_TIMESTAMP\r\n    WHERE incident_id = ${incidentId} AND patient_letter = ${patientLetter}\r\n    RETURNING *\r\n  `;\r\n  \r\n  return result[0];\r\n}\r\n\r\n// ePRF Data operations (form data)\r\nexport async function saveEPRFData(\r\n  incidentId: string,\r\n  patientLetter: string,\r\n  section: string,\r\n  data: any\r\n) {\r\n  const sql = getDb();\r\n  \r\n  const result = await sql`\r\n    INSERT INTO eprf_data (incident_id, patient_letter, section, data)\r\n    VALUES (${incidentId}, ${patientLetter}, ${section}, ${JSON.stringify(data)})\r\n    ON CONFLICT (incident_id, patient_letter, section) \r\n    DO UPDATE SET data = ${JSON.stringify(data)}, updated_at = CURRENT_TIMESTAMP\r\n    RETURNING *\r\n  `;\r\n  \r\n  return result[0];\r\n}\r\n\r\nexport async function getEPRFData(incidentId: string, patientLetter: string, section: string) {\r\n  const sql = getDb();\r\n  \r\n  const result = await sql`\r\n    SELECT data FROM eprf_data \r\n    WHERE incident_id = ${incidentId} \r\n    AND patient_letter = ${patientLetter} \r\n    AND section = ${section}\r\n  `;\r\n  \r\n  return result[0]?.data || null;\r\n}\r\n\r\nexport async function getAllEPRFData(incidentId: string, patientLetter: string) {\r\n  const sql = getDb();\r\n  \r\n  const result = await sql`\r\n    SELECT section, data FROM eprf_data \r\n    WHERE incident_id = ${incidentId} AND patient_letter = ${patientLetter}\r\n  `;\r\n  \r\n  // Convert to object with section names as keys\r\n  const dataObj: { [key: string]: any } = {};\r\n  for (const row of result) {\r\n    dataObj[row.section] = row.data;\r\n  }\r\n  \r\n  return dataObj;\r\n}\r\n\r\n// User operations\r\nexport async function upsertUser(\r\n  discordId: string,\r\n  discordUsername: string,\r\n  callsign: string,\r\n  vehicle: string\r\n) {\r\n  const sql = getDb();\r\n  \r\n  const result = await sql`\r\n    INSERT INTO users (discord_id, discord_username, callsign, vehicle, last_login)\r\n    VALUES (${discordId}, ${discordUsername}, ${callsign}, ${vehicle}, CURRENT_TIMESTAMP)\r\n    ON CONFLICT (discord_id) \r\n    DO UPDATE SET \r\n      discord_username = ${discordUsername},\r\n      callsign = ${callsign},\r\n      vehicle = ${vehicle},\r\n      last_login = CURRENT_TIMESTAMP\r\n    RETURNING *\r\n  `;\r\n  \r\n  return result[0];\r\n}\r\n\r\nexport async function getActiveUsers() {\r\n  const sql = getDb();\r\n  \r\n  // Get users who logged in within the last 24 hours\r\n  const result = await sql`\r\n    SELECT * FROM users \r\n    WHERE last_login > NOW() - INTERVAL '24 hours'\r\n    ORDER BY last_login DESC\r\n  `;\r\n  \r\n  return result;\r\n}\r\n\r\nexport async function getUser(discordId: string) {\r\n  const sql = getDb();\r\n  \r\n  const result = await sql`\r\n    SELECT * FROM users WHERE discord_id = ${discordId}\r\n  `;\r\n  \r\n  return result[0] || null;\r\n}\r\n\r\n// Search and filter ePRFs\r\nexport async function searchEPRFs(\r\n  discordId: string,\r\n  query?: string,\r\n  status?: string,\r\n  dateFrom?: string,\r\n  dateTo?: string\r\n) {\r\n  const sql = getDb();\r\n  \r\n  let result;\r\n  \r\n  if (status && status !== 'all') {\r\n    if (query) {\r\n      result = await sql`\r\n        SELECT * FROM eprf_records \r\n        WHERE author_discord_id = ${discordId}\r\n        AND status = ${status}\r\n        AND (incident_id ILIKE ${'%' + query + '%'} OR patient_letter ILIKE ${'%' + query + '%'})\r\n        ORDER BY created_at DESC\r\n      `;\r\n    } else {\r\n      result = await sql`\r\n        SELECT * FROM eprf_records \r\n        WHERE author_discord_id = ${discordId}\r\n        AND status = ${status}\r\n        ORDER BY created_at DESC\r\n      `;\r\n    }\r\n  } else {\r\n    if (query) {\r\n      result = await sql`\r\n        SELECT * FROM eprf_records \r\n        WHERE author_discord_id = ${discordId}\r\n        AND (incident_id ILIKE ${'%' + query + '%'} OR patient_letter ILIKE ${'%' + query + '%'})\r\n        ORDER BY created_at DESC\r\n      `;\r\n    } else {\r\n      result = await sql`\r\n        SELECT * FROM eprf_records \r\n        WHERE author_discord_id = ${discordId}\r\n        ORDER BY created_at DESC\r\n      `;\r\n    }\r\n  }\r\n  \r\n  return result;\r\n}\r\n\r\n// Admin functions - get ALL ePRF records\r\nexport async function getAllEPRFRecords(\r\n  query?: string,\r\n  status?: string,\r\n  authorId?: string\r\n) {\r\n  const sql = getDb();\r\n  \r\n  let result;\r\n  \r\n  // Build query based on filters\r\n  if (authorId && status && status !== 'all') {\r\n    if (query) {\r\n      result = await sql`\r\n        SELECT r.*, u.callsign as user_callsign, u.discord_username \r\n        FROM eprf_records r\r\n        LEFT JOIN users u ON r.author_discord_id = u.discord_id\r\n        WHERE r.author_discord_id = ${authorId}\r\n        AND r.status = ${status}\r\n        AND (r.incident_id ILIKE ${'%' + query + '%'} OR r.patient_letter ILIKE ${'%' + query + '%'} OR r.author_callsign ILIKE ${'%' + query + '%'})\r\n        ORDER BY r.created_at DESC\r\n      `;\r\n    } else {\r\n      result = await sql`\r\n        SELECT r.*, u.callsign as user_callsign, u.discord_username \r\n        FROM eprf_records r\r\n        LEFT JOIN users u ON r.author_discord_id = u.discord_id\r\n        WHERE r.author_discord_id = ${authorId}\r\n        AND r.status = ${status}\r\n        ORDER BY r.created_at DESC\r\n      `;\r\n    }\r\n  } else if (authorId) {\r\n    if (query) {\r\n      result = await sql`\r\n        SELECT r.*, u.callsign as user_callsign, u.discord_username \r\n        FROM eprf_records r\r\n        LEFT JOIN users u ON r.author_discord_id = u.discord_id\r\n        WHERE r.author_discord_id = ${authorId}\r\n        AND (r.incident_id ILIKE ${'%' + query + '%'} OR r.patient_letter ILIKE ${'%' + query + '%'} OR r.author_callsign ILIKE ${'%' + query + '%'})\r\n        ORDER BY r.created_at DESC\r\n      `;\r\n    } else {\r\n      result = await sql`\r\n        SELECT r.*, u.callsign as user_callsign, u.discord_username \r\n        FROM eprf_records r\r\n        LEFT JOIN users u ON r.author_discord_id = u.discord_id\r\n        WHERE r.author_discord_id = ${authorId}\r\n        ORDER BY r.created_at DESC\r\n      `;\r\n    }\r\n  } else if (status && status !== 'all') {\r\n    if (query) {\r\n      result = await sql`\r\n        SELECT r.*, u.callsign as user_callsign, u.discord_username \r\n        FROM eprf_records r\r\n        LEFT JOIN users u ON r.author_discord_id = u.discord_id\r\n        WHERE r.status = ${status}\r\n        AND (r.incident_id ILIKE ${'%' + query + '%'} OR r.patient_letter ILIKE ${'%' + query + '%'} OR r.author_callsign ILIKE ${'%' + query + '%'})\r\n        ORDER BY r.created_at DESC\r\n      `;\r\n    } else {\r\n      result = await sql`\r\n        SELECT r.*, u.callsign as user_callsign, u.discord_username \r\n        FROM eprf_records r\r\n        LEFT JOIN users u ON r.author_discord_id = u.discord_id\r\n        WHERE r.status = ${status}\r\n        ORDER BY r.created_at DESC\r\n      `;\r\n    }\r\n  } else {\r\n    if (query) {\r\n      result = await sql`\r\n        SELECT r.*, u.callsign as user_callsign, u.discord_username \r\n        FROM eprf_records r\r\n        LEFT JOIN users u ON r.author_discord_id = u.discord_id\r\n        WHERE r.incident_id ILIKE ${'%' + query + '%'} OR r.patient_letter ILIKE ${'%' + query + '%'} OR r.author_callsign ILIKE ${'%' + query + '%'}\r\n        ORDER BY r.created_at DESC\r\n      `;\r\n    } else {\r\n      result = await sql`\r\n        SELECT r.*, u.callsign as user_callsign, u.discord_username \r\n        FROM eprf_records r\r\n        LEFT JOIN users u ON r.author_discord_id = u.discord_id\r\n        ORDER BY r.created_at DESC\r\n      `;\r\n    }\r\n  }\r\n  \r\n  return result;\r\n}\r\n\r\n// Admin: Get all users\r\nexport async function getAllUsers() {\r\n  const sql = getDb();\r\n  \r\n  const result = await sql`\r\n    SELECT * FROM users \r\n    ORDER BY last_login DESC\r\n  `;\r\n  \r\n  return result;\r\n}\r\n\r\n// Admin: Force delete any ePRF (even complete ones)\r\nexport async function adminDeleteEPRFRecord(incidentId: string, patientLetter: string) {\r\n  const sql = getDb();\r\n  \r\n  // Delete data first\r\n  await sql`\r\n    DELETE FROM eprf_data \r\n    WHERE incident_id = ${incidentId} AND patient_letter = ${patientLetter}\r\n  `;\r\n  \r\n  // Then delete the record (no status check)\r\n  const result = await sql`\r\n    DELETE FROM eprf_records \r\n    WHERE incident_id = ${incidentId} AND patient_letter = ${patientLetter}\r\n    RETURNING *\r\n  `;\r\n  \r\n  return result[0] || null;\r\n}\r\n\r\n// Admin: Update ePRF record\r\nexport async function adminUpdateEPRFRecord(\r\n  incidentId: string, \r\n  patientLetter: string,\r\n  updates: {\r\n    status?: string;\r\n    author_discord_id?: string;\r\n    author_callsign?: string;\r\n  }\r\n) {\r\n  const sql = getDb();\r\n  \r\n  const result = await sql`\r\n    UPDATE eprf_records \r\n    SET \r\n      status = COALESCE(${updates.status}, status),\r\n      author_discord_id = COALESCE(${updates.author_discord_id}, author_discord_id),\r\n      author_callsign = COALESCE(${updates.author_callsign}, author_callsign),\r\n      updated_at = CURRENT_TIMESTAMP\r\n    WHERE incident_id = ${incidentId} AND patient_letter = ${patientLetter}\r\n    RETURNING *\r\n  `;\r\n  \r\n  return result[0];\r\n}\r\n"],"names":["module","exports","require","runtime","GET","request","searchParams","URL","url","incidentId","get","patientLetter","section","Response","json","success","error","status","data","getEPRFData","getAllEPRFData","console","message","POST","undefined","result","saveEPRFData","routeModule","module_compiled","AppRouteRouteModule","definition","kind","route_kind","x","APP_ROUTE","page","pathname","filename","bundlePath","resolvedPagePath","nextConfigOutput","userland","route_namespaceObject","requestAsyncStorage","staticGenerationAsyncStorage","serverHooks","originalPathname","patchFetch","patch_fetch","XH","ComponentMod","route_next_edge_ssr_entry_namespaceObject","next_edge_app_route_loaderabsolutePagePath_private_next_app_dir_2Fapi_2Feprf_2Fdata_2Froute_js_page_2Fapi_2Feprf_2Fdata_2Froute_appDirLoader_bmV4dC1hcHAtbG9hZGVyP25hbWU9YXBwJTJGYXBpJTJGZXByZiUyRmRhdGElMkZyb3V0ZSZwYWdlPSUyRmFwaSUyRmVwcmYlMkZkYXRhJTJGcm91dGUmcGFnZVBhdGg9cHJpdmF0ZS1uZXh0LWFwcC1kaXIlMkZhcGklMkZlcHJmJTJGZGF0YSUyRnJvdXRlLmpzJmFwcERpcj1DJTNBJTVDVXNlcnMlNUNUb2J5JTVDRG93bmxvYWRzJTVDbm9kZS12MjQuMTEuMS13aW4teDY0JTVDYXBwMTIzJTVDYXBwJmFwcFBhdGhzPSUyRmFwaSUyRmVwcmYlMkZkYXRhJTJGcm91dGUmcGFnZUV4dGVuc2lvbnM9dHN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPWpzeCZwYWdlRXh0ZW5zaW9ucz1qcyZiYXNlUGF0aD0mYXNzZXRQcmVmaXg9Jm5leHRDb25maWdPdXRwdXQ9JnByZWZlcnJlZFJlZ2lvbj0mbWlkZGxld2FyZUNvbmZpZz1lMzAlM0Qh_nextConfigOutput_preferredRegion_middlewareConfig_e30_3D_","edge_route_module_wrapper","a","wrap","getDb","process","env","DATABASE_URL","neon","initializeDatabase","sql","createEPRFRecord","authorDiscordId","authorCallsign","fleetId","getEPRFRecord","markEPRFComplete","deleteEPRFRecord","transferEPRF","newAuthorDiscordId","newAuthorCallsign","JSON","stringify","dataObj","row","upsertUser","discordId","discordUsername","callsign","vehicle","getActiveUsers","getUser","searchEPRFs","query","dateFrom","dateTo","getAllEPRFRecords","authorId","getAllUsers","adminDeleteEPRFRecord","adminUpdateEPRFRecord","updates","author_discord_id","author_callsign"],"sourceRoot":""}